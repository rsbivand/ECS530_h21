---
title: "ECS530: Spatial Data Analysis V"
author: "Roger Bivand"
date: "Friday 18 November 2021"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
    toc_depth: 2
theme: united
bibliography: ecs530_21.bib
link-citations: yes
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Copyright

All the material presented here, to the extent it is original, is available under [CC-BY-SA](https://creativecommons.org/licenses/by-sa/4.0/). Parts build on joint tutorials with Edzer Pebesma.

### Required current contributed CRAN packages:

I am running R 4.1.2, with recent `update.packages()`.

```{r, echo=TRUE}
needed <- c("stars", "abind", "raster", "spatstat", "spatstat.linnet", "spatstat.core",
"spatstat.geom", "spatstat.data", "ranger", "automap", "RColorBrewer", "gstat",
"ggplot2", "R2BayesX", "colorspace", "HSAR", "hglm", "sp", "lme4", "spfilteR",
"spmoran", "spatialreg", "spData", "tmap", "sf")
```

### Script

Script and data at https://github.com/rsbivand/ECS530_h21/raw/main/ECS530_211119.zip. Download to suitable location, unzip and use as basis.

# Spatial filtering

Spatial filtering methods as developed by @griffith03 build on using standard
linear and generalized linear models supplemented with selected eigenvectors from the
spatial weights matrix. In @JORS:JORS759, @griffith10 and
@griffith+paelinck:11, examples were given of how standard and non-standard
spatial econometric problems could be approached using spatial filtering.
@tiefelsdorf+griffith:07 proposed that the eigenvectors for inclusion should be
selected by their ability to reduce residual autocorrelation rather than to increase
model fit. This approach was implemented by Yongwan Chun and Michael Tiefelsdorf in **spdep** and moved to **spatialreg**, with two steps, first to select eigenvectors taken from
the spatial weights matrix doubly centred using the hat matrix of the actual
regression, then using `lm` to fit the model, effectively removing residual
autocorrelation:


## Upper NY data

The New York 8 county data set contains population standardized leukaemia cases, with `Z` as a transformed rate:

```{r, echo=TRUE}
library(sf)
NY8 <- st_read(system.file("shapes/NY8_utm18.shp", package="spData"))
NY8 <- st_buffer(NY8, dist=0)
```


```{r, echo=TRUE}
library(tmap)
tm_shape(NY8) + tm_fill("Z", midpoint=0)
```

Create a neighbour object:

```{r, echo=TRUE}
NY_nb <- spdep::poly2nb(NY8)
NY_lwB <- spdep::nb2listw(NY_nb, style="B")
NY_lwW <- spdep::nb2listw(NY_nb, style="W")
```

Check how the SAR and CAR models behave, with and without case weights:

```{r, echo=TRUE}
library(spatialreg)
gform <- Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME
mod1 <- spautolm(gform, data=NY8, family="CAR", listw=NY_lwB, weights=POP8)
summary(mod1)
```

This data set is used Waller and Gotway [-@WallerGotway:2004], and in both editions of ASDAR. It is harder to deploy Poisson models because the cases are not integer counts.


```{r, echo=TRUE}
(SF0 <- SpatialFiltering(gform, data = NY8, nb=NY_nb, style="W"))
```

```{r, echo=TRUE}
SF_obj2 <- lm(update(gform, . ~ . + fitted(SF0)), data = NY8)
summary(SF_obj2)
```

```{r, echo=TRUE}
spdep::lm.morantest(SF_obj2, NY_lwW)
```

```{r, echo=TRUE}
vecs <- fitted(SF0)
pvecs <- vecs %*% diag(coefficients(SF_obj2)[5:14])
colnames(pvecs) <- colnames(vecs)
```

Typically, the small subset of
eigenvectors selected mops up spatial autocorrelation in the residual.
@dray+legendre+peres-neto:06 and @griffith+peres-neto:06 adopt a similar
approach in a generalized linear model context, implemented in **spdep** by Pedro
Peres-Neto and moved now to **spatialreg** as `ME` analogous with
`SpatialFiltering`, but centering the spatial weights matrix on the null model
hat matrix, and using bootstrap methods in evaluating the the choice of eigenvectors.
The correlations between the implied cumulated outcomes of these methods are shown in
Table \ref{tab:cor_RE}. @drayetal12 describe many of the underlying motivations,
including the view that Moran eigenvector spatial filtering approaches may permit both
spatial autocorrelation and spatial scale tto be accommodate in a single model; a
further implementation is given in @adespatial-package.

```{r, echo=TRUE}
set.seed(22)
(ME0 <- ME(gform, data = NY8, listw=NY_lwW, alpha=0.15, nsim=99))
```

```{r, echo=TRUE}
ME_obj2 <- lm(update(gform, . ~ . + fitted(ME0)), data = NY8)
summary(ME_obj2)
```

```{r, echo=TRUE}
mvecs <- fitted(ME0) %*% diag(coefficients(ME_obj2)[5:7])
sem_obj2a <- spautolm(gform, NY8, listw=NY_lwW)
W <- as(NY_lwW, "CsparseMatrix")
SAR_ssre <- 2*as.vector((sem_obj2a$lambda * W) %*% sem_obj2a$Y - (sem_obj2a$lambda * W) %*% (sem_obj2a$X %*% sem_obj2a$fit$coefficients))
```

@https://doi.org/10.1111/gean.12156 provide a fresher version of spatial
filtering implemented in @spmoran-package. This also appears to centre the
spatial weights matrix on the null model hat matrix, and chooses eigenvectors not to
reduce residual autocorrelation, but chooses those among the eigenvectors with
positive eigenvalues that increase model fit most up to a threshold to control
overfitting. The default approach uses an exponential variogram model to generate the
weights matrix from planar coordinates. The `meigen` function subsets the full
set of eigenvectors before the data are seen, then `esf` calls `lm` itself
while further subsetting the eigenvectors.

```{r, echo=TRUE}
library(spmoran)
centroids_utm <- st_centroid(st_geometry(NY8))
meig <- meigen(st_coordinates(centroids_utm))
```

```{r, echo=TRUE} 
y <- model.response(model.frame(gform, NY8))
X <- model.matrix(update(gform, ~ .), NY8)
(esf_obj2 <- esf(y, X, meig=meig))
```
```{r}
esf_obj2$r
```


```{r, echo=TRUE}
r_used_eigs <- row.names(esf_obj2$r)
used_eigs <- as.integer(substring(r_used_eigs, 3))
evecs <- meig$sf[, used_eigs] %*% diag(esf_obj2$r[1:length(r_used_eigs),1])
colnames(evecs) <- r_used_eigs
```


@RJ-2021-085 describes another implementation [@spfilteR-package], permitting the choice of function to be optimised:

```{r, echo=TRUE}
library(spfilteR)
set.seed(1)
spfMI_obj <- lmFilter(y=y, x=X[,-1], W=as.matrix(W), objfn="MI", positive = FALSE, tol = .2)
summary(spfMI_obj)
```

```{r, echo=TRUE}
spfvecs <- spfMI_obj$selvecs %*% diag(spfMI_obj$EV[,1])
```

```{r, echo=TRUE}
SEs <- cbind("ESF"=apply(evecs, 1, sum), "SF"=apply(pvecs, 1, sum), "SPF"=apply(spfvecs, 1, sum), "ME"=apply(mvecs, 1, sum), "SAR"=SAR_ssre)
NY8_SEs <- cbind(NY8, SEs)
mat <- cor(SEs)
colnames(mat) <- rownames(mat) <- c("ESF", "SF", "SPF", "ME", "SAR")
mat
```


The correlations between four cumulated spatial filtering approaches, and the
spatially structured term implied by the ML estimates of the spatial
error model. Differences are related to weighting of the linear model, and centring on the full or null model. As can be seen, they are very similar to each other, so the choice of approach may be fairly flexible and relate more to the needs of users and their domain usages that to a single body of theory.

```{r}
tm_shape(NY8_SEs) + tm_fill(c("ESF", "SF", "SPF", "ME", "SAR"), n=8, palette="BrBG", midpoint=0, title="Spatial effect") + tm_facets(free.scales=FALSE) + tm_borders(lwd=0.5) + tm_layout(panel.labels=c("ESF", "SF", "SPF", "ME", "SAR"), bg="grey90")
```


## NC SIDS data

```{r, message=FALSE, warning=FALSE}
nc <- st_read(system.file("shapes/sids.shp", package="spData")[1], quiet=TRUE)
st_crs(nc) <- "EPSG:4267"
row.names(nc) <- as.character(nc$FIPSNO)
nc$ft.SID74 <- sqrt(1000)*(sqrt(nc$SID74/nc$BIR74) + sqrt((nc$SID74+1)/nc$BIR74))
nc$ft.NWBIR74 <- sqrt(1000)*(sqrt(nc$NWBIR74/nc$BIR74) + sqrt((nc$NWBIR74+1)/nc$BIR74))
gal_file <- system.file("weights/ncCR85.gal", package="spData")[1]
ncCR85 <- spdep::read.gal(gal_file, region.id=nc$FIPSNO)
nc_lw <- spdep::nb2listw(ncCR85, style="B")
nc_W <- as(nc_lw, "CsparseMatrix")
```


```{r, echo=TRUE}
E <- nc$BIR74 * sum(nc$SID74)/sum(nc$BIR74)
set.seed(1001)
(ME_nc_p <- ME(SID74 ~ ft.NWBIR74, offset=log(E), weights=BIR74, data=nc, family=poisson(link=log), listw=nc_lw, alpha=0.25, nsim=499))
```

```{r, echo=TRUE}
ME_obj_nc0 <- glm(SID74 ~ ft.NWBIR74, offset=log(E), weights=BIR74, data=nc, family=poisson(link=log))
summary(ME_obj_nc0)
```

```{r, echo=TRUE}
ME_obj_nc <- glm(update(SID74 ~ ft.NWBIR74, . ~ . + fitted(ME_nc_p)), offset=log(E), weights=BIR74, data=nc, family=poisson(link=log))
summary(ME_obj_nc)
```

```{r}
anova(ME_obj_nc0, ME_obj_nc, test="Chisq")
```


# Markov random field and multilevel models with spatial weights

## Boston data set


```{r}
boston_506 <- st_read(system.file("shapes/boston_tracts.shp", package="spData")[1])
```
```{r}
nb_q <- spdep::poly2nb(boston_506)
lw_q <- spdep::nb2listw(nb_q, style="W")
```

```{r}
boston_506$CHAS <- as.factor(boston_506$CHAS)
boston_489 <- boston_506[!is.na(boston_506$median),]
nb_q_489 <- spdep::poly2nb(boston_489)
lw_q_489 <- spdep::nb2listw(nb_q_489, style="W", zero.policy=TRUE)
```

```{r}
agg_96 <- list(as.character(boston_506$NOX_ID))
boston_96 <- aggregate(boston_506[, "NOX_ID"], by=agg_96, unique)
nb_q_96 <- spdep::poly2nb(boston_96)
lw_q_96 <- spdep::nb2listw(nb_q_96)
boston_96$NOX <- aggregate(boston_506$NOX, agg_96, mean)$x
boston_96$CHAS <- aggregate(as.integer(boston_506$CHAS)-1, agg_96, max)$x
```

```{r}
nms <- names(boston_506)
ccounts <- 23:31
for (nm in nms[c(22, ccounts, 36)]) {
  boston_96[[nm]] <- aggregate(boston_506[[nm]], agg_96, sum)$x
}
br2 <- c(3.50,  6.25,  8.75, 12.50, 17.50, 22.50, 30.00, 42.50, 60.00)*1000
counts <- as.data.frame(boston_96)[, nms[ccounts]]
f <- function(x) matrixStats::weightedMedian(x=br2, w=x, interpolate=TRUE)
boston_96$median <- apply(counts, 1, f)
is.na(boston_96$median) <- boston_96$median > 50000
summary(boston_96$median)
```

```{r, echo=FALSE}
POP <- boston_506$POP
f <- function(x) matrixStats::weightedMean(x[,1], x[,2])
for (nm in nms[c(9:11, 14:19, 21, 33)]) {
  s0 <- split(data.frame(boston_506[[nm]], POP), agg_96)
  boston_96[[nm]] <- sapply(s0, f)
}
```
```{r}
boston_94 <- boston_96[!is.na(boston_96$median),]
nb_q_94 <- spdep::subset.nb(nb_q_96, !is.na(boston_96$median))
lw_q_94 <- spdep::nb2listw(nb_q_94, style="W")
```


There is a large literature in spatial epidemiology using CAR and ICAR models in spatially structured random effects. These extend to multilevel models, in which the spatially structured random effects may apply at different levels of the model [@bivandetal17a]. In order to try out some of the variants, we need to remove the no-neighbour observations from the tract level, and from the model output zone aggregated level, in two steps as reducing the tract level induces a no-neighbour outcome at the model output zone level.

```{r}
boston_94a <- aggregate(boston_489[,"NOX_ID"], list(boston_489$NOX_ID), unique)
nb_q_94a <- spdep::poly2nb(boston_94a)
NOX_ID_no_neighs <- boston_94a$NOX_ID[which(spdep::card(nb_q_94a) == 0)]
boston_487 <- boston_489[is.na(match(boston_489$NOX_ID, NOX_ID_no_neighs)),]
boston_93 <- aggregate(boston_487[, "NOX_ID"], list(ids = boston_487$NOX_ID), unique)
row.names(boston_93) <- as.character(boston_93$NOX_ID)
nb_q_93 <- spdep::poly2nb(boston_93, row.names=unique(as.character(boston_93$NOX_ID)))
```
The **lme4** package lets us add an IID unstructured random effect at the model output zone level:

```{r}
form <- formula(log(median) ~ CRIM + ZN + INDUS + CHAS + I((NOX*10)^2) + I(RM^2) + 
                  AGE + log(DIS) + log(RAD) + TAX + PTRATIO + I(BB/100) + 
                  log(I(LSTAT/100)))
```

The ZN, INDUS, NOX, RAD, TAX and PTRATIO variables show effectively no variability within the TASSIM zones, so in a multilevel model the random effect may absorb their influence. 


```{r}
library(lme4)
MLM <- lmer(update(form, . ~ . + (1 | NOX_ID)), data=boston_487, REML=FALSE)
```
copying the random effect into the `"sf"` object for mapping below.

```{r}
boston_93$MLM_re <- ranef(MLM)[[1]][,1]
```
Two packages, **hglm** and **HSAR**, offer SAR upper level spatially structured random effects, and require the specification of a sparse matrix mapping the upper level enities onto lower level entities, and sparse binary weights matrices:

```{r}
library(Matrix)
suppressMessages(library(MatrixModels))
Delta <- as(model.Matrix(~ -1 + as.factor(NOX_ID), data=boston_487, sparse=TRUE),
            "dgCMatrix")
M <- as(spdep::nb2listw(nb_q_93, style="B"), "CsparseMatrix")
```
The extension of **hglm** to sparse spatial setting extended its facilities [@alam-ronnegard-shen:2015], and also permits the modelling of discrete responses. First we fit an IID random effect:

```{r}
suppressPackageStartupMessages(library(hglm))
y_hglm <- log(boston_487$median)
X_hglm <- model.matrix(lm(form, data=boston_487))
suppressWarnings(HGLM_iid <- hglm(y=y_hglm, X=X_hglm, Z=Delta))
```
followed by a SAR model at the upper level (corresponding to a spatial error (SEM) model), which reports the spatially structured random effect without fully converging, so coefficient standard errors are not available:

```{r}
suppressWarnings(HGLM_sar <- hglm(y=y_hglm, X=X_hglm, Z=Delta, rand.family=SAR(D=M)))
boston_93$HGLM_re <- unname(HGLM_iid$ranef)
boston_93$HGLM_ss <- HGLM_sar$ranef[,1]
```
The **HSAR** package is restricted to the Gaussian response case, and fits an upper level SEM using MCMC; if `W=` is a lower level weights matrix, it will also fit a lower level SLM [@dong+harris:15; @dongetal15]:

```{r}
library(HSAR)
suppressWarnings(HSAR <- hsar(form, data=boston_487, W=NULL, M=M, Delta=Delta, 
                              burnin=500, Nsim=2500, thinning=1))
boston_93$HSAR_ss <- HSAR$Mus[1,]
```
The **R2BayesX** package provides flexible support for structured additive regression models, including spatial multilevel models. The models include an IID unstructured random effect at the upper level using the `"re"` specification [@umlaufetal:15]; we choose the `"MCMC"`method:

```{r}
suppressPackageStartupMessages(library(R2BayesX))
BX_iid <- bayesx(update(form, . ~ . + sx(NOX_ID, bs="re")), family="gaussian",
data=boston_487, method="MCMC", iterations=12000, burnin=2000, step=2, seed=123)
boston_93$BX_re <- BX_iid$effects["sx(NOX_ID):re"][[1]]$Mean
```
and the `"mrf"` (Markov random field) spatially structured random effect specification based on a graph derived from converting a suitable `"nb"` object for the upper level. The `"region.id"` attribute of the `"nb"` object needs to contain values corresponding the the indexing variable.

```{r}
RBX_gra <- nb2gra(nb_q_93)
BX_mrf <- bayesx(update(form, . ~ . + sx(NOX_ID, bs="mrf", map=RBX_gra)), 
                 family="gaussian", data=boston_487, method="MCMC", 
                 iterations=12000, burnin=2000,step=2, seed=123)
boston_93$BX_ss <- BX_mrf$effects["sx(NOX_ID):mrf"][[1]]$Mean
```
In a very similar way, `mgcv::gam()` can take an `"mrf"` term using a suitable `"nb"` object for the upper level. In this case the `"nb"` object needs to have the contents of the `"region.id"` attribute copied as the names of the neighbour list components, and the indexing variable needs to be a factor [@wood:17] (the `"REML"` method of `bayesx()` gives the same result here):

```{r}
library(mgcv)
names(nb_q_93) <- attr(nb_q_93, "region.id")
boston_487$NOX_ID <- as.factor(boston_487$NOX_ID)
GAM_MRF <- gam(update(form, . ~ . + s(NOX_ID, bs="mrf", xt=list(nb=nb_q_93))),
               data=boston_487, method="REML")
boston_93$GAM_ss <- aggregate(predict(GAM_MRF, type="terms", se=FALSE)[,14],
                              list(boston_487$NOX_ID), mean)$x
```
In the cases of `hglm()`, `bayesx()` and `gam()`, we could also model discrete responses without further major difficulty, and `bayesx()` and `gam()` also facilitate the generalization of functional form fitting for included covariates.

```{r}
res <- rbind(iid_lmer=summary(MLM)$coefficients[6, 1:2],
             iid_hglm=summary(HGLM_iid)$FixCoefMat[6, 1:2], 
             iid_BX=BX_iid$fixed.effects[6, 1:2], 
             sar_hsar=c(HSAR$Mbetas[1, 6], HSAR$SDbetas[1, 6]),
             mrf_BX=BX_mrf$fixed.effects[6, 1:2], 
             mrf_GAM=c(summary(GAM_MRF)$p.coeff[6], summary(GAM_MRF)$se[6]))
```
Unfortunately, the coefficient estimates for the air pollution variable for these multilevel models are not helpful. All remain negative, but the inclusion of the model output zone level effects, be they IID or spatially structured, suggest that it is hard to disentangle the influence of the scale of observation from that of covariates observed at that scale.

```{r multi-levelcoefs}
suppressPackageStartupMessages(library(ggplot2))
df_res <- as.data.frame(res)
names(df_res) <- c("mean", "sd")
limits <- aes(ymax = mean + qnorm(0.975)*sd, ymin=mean + qnorm(0.025)*sd)
df_res$model <- row.names(df_res)
p <- ggplot(df_res, aes(y=mean, x=model)) + geom_point() + geom_errorbar(limits) + geom_hline(yintercept = 0, col="#EB811B") + coord_flip()
p + ggtitle("NOX coefficients and error bars") + theme(plot.background = element_rect(fill = "transparent",colour = NA), legend.background = element_rect(colour = NA, fill = "transparent"))
```
This map shows that the model output zone level IID random effects are very similar across the three model fitting functions reported.

```{r multi-levelmaps1}
library(tmap)
tm_shape(boston_93) + tm_fill(c("MLM_re", "HGLM_re" , "BX_re"), midpoint=0, title="IID")  + tm_facets(free.scales=FALSE) + tm_borders(lwd=0.3, alpha=0.4) + tm_layout(panel.labels=c("MLM", "HGLM", "BX"))
```
The spatially structured SAR and MRF random effects (MRF term in the `gam()` case) are also very similar, with the MRF somewhat less smoothed than the SAR values.

```{r multilevelmaps2, out.width='100%', fig.cap="Spatially structured random effects", fig=TRUE}
tm_shape(boston_93) + tm_fill(c("HGLM_ss", "HSAR_ss", "BX_ss", "GAM_ss"), midpoint=0, title="SS")  + tm_facets(free.scales=FALSE) + tm_borders(lwd=0.3, alpha=0.4) + tm_layout(panel.labels=c("HGLM SAR", "HSAR SAR", "BX MRF", "GAM MRF"))
```
Although there is still a great need for more thorough comparative studies of model fitting functions for spatial regression, there has been much progress over recent years. This is not completed as a proper set of comparisons with this data set -  [@bivandetal17a; @bivand17] contains comparisons for Beijing land parcels and a housing data set for SW Norway.


## NC SIDS data

```{r, message=FALSE, warning=FALSE}
nc <- st_read(system.file("shapes/sids.shp", package="spData")[1], quiet=TRUE)
st_crs(nc) <- "EPSG:4267"
row.names(nc) <- as.character(nc$FIPSNO)
nc$ft.SID74 <- sqrt(1000)*(sqrt(nc$SID74/nc$BIR74) + sqrt((nc$SID74+1)/nc$BIR74))
nc$ft.NWBIR74 <- sqrt(1000)*(sqrt(nc$NWBIR74/nc$BIR74) + sqrt((nc$NWBIR74+1)/nc$BIR74))
gal_file <- system.file("weights/ncCR85.gal", package="spData")[1]
ncCR85 <- spdep::read.gal(gal_file, region.id=nc$FIPSNO)
nc_lw <- spdep::nb2listw(ncCR85, style="B")
nc_W <- as(nc_lw, "CsparseMatrix")
```


The approach taken by social scientists including economists, and some others has been to approach this through simultaneous autoregressive approaches, where the response is modelled using fixed covariates, and the residual process is modelled by optimising a log likelihood function. The **spatialreg** package provides `spautolm()` and `errorsarlm()`:

```{r, echo=TRUE, results='hide', message=FALSE, warning=FALSE}
m1 <- spautolm(ft.SID74 ~ ft.NWBIR74, weights=BIR74, data=nc, listw=nc_lw, family="SAR")
```

When we include the covariate, the spatial error coefficient contributes little:

```{r, echo=TRUE}
summary(m1)
```

It is unusual to present maps of the spatially structured random effect in cases where the simultaneous autoregressive approach is used, but it is fully possible using components of the returned model object (the vector is doubled for comparison with the CAR version):

```{r, echo=TRUE}
nc$SAR_ssre <- 2*as.vector((m1$lambda * nc_W) %*% m1$Y - (m1$lambda * nc_W) %*% (m1$X %*% m1$fit$coefficients))
library(tmap)
tm_shape(nc) + tm_fill(c("ft.SID74", "SAR_ssre"), midpoint=c(NA, 0))
```


The other maximum likelihood implementation gives the same results, but provides a Hausman test for shifts in the covariate coefficients between the aspatial and spatial estimates [@pace+lesage:08]; there is none:

```{r, echo=TRUE, message=FALSE, warning=FALSE}
m1a <- errorsarlm(ft.SID74 ~ ft.NWBIR74, weights=BIR74, data=nc, listw=nc_lw)
summary(m1a, Hausman=TRUE)
```

It also lets us add `Durbin=` terms, that is spatially lagged covariates:

```{r, echo=TRUE, message=FALSE, warning=FALSE}
m1b <- errorsarlm(ft.SID74 ~ ft.NWBIR74, weights=BIR74, data=nc, listw=nc_lw, Durbin=TRUE)
summary(m1b, Hausman=TRUE)
```

and to present the by-covariate effects taking into account the unlagged (direct) and lagged (indirect) covariates and the sum of the coefficients (total):

```{r, echo=TRUE, message=FALSE, warning=FALSE}
summary(impacts(m1b))
```


However, our model may suffer from not using a mixed model approach to a count response; the simultaneous autoregressive models are mostly used with Gaussian responses. One possibility is to employ the hierarchical generalized linear model approach from the **hglm** package. First we'll fit an unstructured IID (independent and identically distributed) random effect [@alam-ronnegard-shen:2015]:

```{r, echo=TRUE, results='hide', message=FALSE, warning=FALSE}
library(hglm)
E <- nc$BIR74 * sum(nc$SID74)/sum(nc$BIR74)
HGLM_iid <- hglm(fixed=SID74 ~ ft.NWBIR74, random= ~ 1|CRESS_ID, offset=log(E), weights=BIR74,
                 data=nc, family=poisson(link=log))
```

The random effects also have their own standard errors, so we can order and display them with error bars in a forest or caterpillar plot:

```{r, echo=TRUE}
ranef_iid <- unname(summary(HGLM_iid, print.ranef=TRUE)$RandCoefMat)
metafor::forest(ranef_iid[,1], ranef_iid[,2], subset=order(ranef_iid[,1], decreasing=TRUE), 
        slab=NA, annotate=FALSE, lty=c("solid","blank"), pch=19, psize=2, cex.lab=1, cex.axis=1)
```

We can also fit a weighted Poisson simultaneous autoregressive model, and examine the random effects:

```{r, echo=TRUE, results='hide', message=FALSE, cache=TRUE, warning=FALSE}
HGLM_sar <- hglm(fixed=SID74 ~ ft.NWBIR74, random= ~ 1|CRESS_ID, offset=log(E), weights=BIR74, 
                 data=nc, family=poisson(link=log), rand.family=SAR(D=nc_W))
ranef_sar <- unname(summary(HGLM_sar, print.ranef=TRUE)$RandCoefMat)
metafor::forest(ranef_sar[,1], ranef_sar[,2], subset=order(ranef_sar[,1], decreasing=TRUE), 
        slab=NA, annotate=FALSE, lty=c("solid","blank"), pch=19, psize=2, cex.lab=1, cex.axis=1)
```

There is not much difference between the IID and the SAR spatially structured random effects:

```{r, echo=TRUE}
nc$HGLM_re <- ranef_iid[,1]
nc$HGLM_ss_SAR <- ranef_sar[,1]
tm_shape(nc) + tm_fill(c("HGLM_re", "HGLM_ss_SAR"), midpoint=c(0), title="Poisson HGLM RE") +
  tm_facets(free.scales=FALSE) + tm_layout(panel.labels=c("IID", "SAR SSRE"))
```

##  Conditional and MRF autoregressive approaches

Most epidemiological applications use conditional autoregressive approaches, where some (like `spautolm()` and the `hglm()` implementations) fit a spatial coefficient, but many fit an intrinsic CAR. First the `spautolm()` and the `hglm()` implementations:

```{r, echo=TRUE}
m1c <- spautolm(ft.SID74 ~ ft.NWBIR74, weights=BIR74, data=nc, listw=nc_lw, family="CAR")
summary(m1c)
```

Again, we can calculate something that represents the spatial patterning of the spatial process (termed "signal" in the documentation of `spatialreg::predict.sarlm`), but it is not scaled in the same way as the `hgml()` random effects (and importantly we do not have standard errors):

```{r, echo=TRUE}
nc$CAR_ssre <- as.vector((m1c$lambda * nc_W) %*% m1c$Y - 
                           (m1c$lambda * nc_W) %*% (m1c$X %*% m1c$fit$coefficients))
tm_shape(nc) + tm_fill(c("SAR_ssre", "CAR_ssre"), midpoint=c(0), title="Gauss ML RE") +
  tm_facets(free.scales=FALSE) + tm_layout(panel.labels=c("SAR SSRE", "CAR SSRE"))
```

Fitting the HGLM CAR model is just like the SAR model, and the forest plot of the spatially structured random effect is similar. Recall that `spautolm()` is fitting a Gaussian model, but `hglm()` is fitting a Poisson model, arguably better suited to count data. This means that the scalings of the random effects will vary in scale:

```{r, echo=TRUE, results='hide', message=FALSE, cache=TRUE, warning=FALSE}
HGLM_car <- hglm(fixed=SID74 ~ ft.NWBIR74, random= ~ 1|CRESS_ID, offset=log(E), weights=BIR74, 
                 data=nc, family=poisson(link=log), rand.family=CAR(D=nc_W))
ranef_car <- unname(summary(HGLM_car, print.ranef=TRUE)$RandCoefMat)
metafor::forest(ranef_car[,1], ranef_car[,2], subset=order(ranef_car[,1], decreasing=TRUE), 
        slab=NA, annotate=FALSE, lty=c("solid","blank"), pch=19, psize=2, cex.lab=1, cex.axis=1)
```

```{r, echo=TRUE}
nc$HGLM_ss_CAR <- ranef_car[,1]
tm_shape(nc) + tm_fill(c("HGLM_ss_CAR", "HGLM_ss_SAR"), midpoint=c(0), title="Poisson HGLM RE") +
  tm_facets(free.scales=FALSE) + tm_layout(panel.labels=c("CAR SSRE", "SAR SSRE"))
```

To use a generalized additive mixed model (`mgcv::gam()` with an `"mrf"` random effect), and some other mixed models, the areal entities need to be grouped (done in the first exercise), and we can try a flexible fit on the covariate:

```{r, echo=TRUE, results='hide', message=FALSE, cache=TRUE, warning=FALSE}
nc$LM <- as.numeric(interaction(nc$L_id, nc$M_id))
aggLM <- aggregate(nc[,"LM"], list(nc$LM), head, n=1)
aggnb <- spdep::poly2nb(aggLM)
library(mgcv)
names(aggnb) <- as.character(aggLM$Group.1)
nc$LM <- as.factor(nc$LM)
GAM_mrf <- gam(SID74 ~ s(ft.NWBIR74) + s(LM, bs="mrf", xt=list(nb=aggnb)), offset=log(E), weights=BIR74, data=nc, family=poisson(link=log))
summary(GAM_mrf)
```

And plot the covariate smooth term:

```{r, echo=TRUE}
library(mgcv)
plot(GAM_mrf)
```

The forest plot is obviously grouped too:

```{r, echo=TRUE}
GAM_mrf_re <- predict(GAM_mrf, type="terms", se=TRUE)
metafor::forest(GAM_mrf_re$fit[,2], GAM_mrf_re$se.fit[,2], subset=order(GAM_mrf_re$fit[,1], decreasing=TRUE), 
        slab=NA, annotate=FALSE, lty=c("solid","blank"), pch=19, psize=2, cex.lab=1, cex.axis=1)
```

as is the RE map:

```{r, echo=TRUE}
nc$GAM_mrf_re <- GAM_mrf_re$fit[,2]
tm_shape(nc) + tm_fill(c("GAM_mrf_re"), midpoint=c(0), title="Poisson GAM MRF RE")
```

## US Census ACS dataset

```{r}
df_tracts <- st_read("df_tracts.gpkg")
```


```{r}
tr_form <- log(med_inc_cv) ~ log1p(vacancy_rate) + log1p(old_rate) + log1p(black_rate) + log1p(hisp_rate) + log1p(group_pop) + log1p(dens)
```


```{r}
df_tracts$ST <- factor(substring(df_tracts$GEOID, 1, 2))
library(mgcv)
GAM_RE <- gam(update(tr_form, . ~ . + s(ST, bs="re")), data=df_tracts)
summary(GAM_RE)
```


```{r, cache=TRUE}
states <- aggregate(df_tracts["ST"], list(df_tracts$ST), head, n=1)
nb_st <- spdep::poly2nb(states, row.names=as.character(states$ST))
names(nb_st) <- as.character(states$ST)
GAM_MRF <- gam(update(tr_form, . ~ . + s(ST, bs="mrf", k=49, xt=list(nb=nb_st))), data=df_tracts)
summary(GAM_MRF)
```

```{r}
cat(capture.output(print(anova(GAM_RE, GAM_MRF, test="Chisq")))[c(1, 2, 9:11)], sep="\n")
```

# Interpolation

### Outline

What is interpolation, and what does it require with regard to data, observation and prediction locations?

The support of the observation and prediction locations - what is it, and how does it affect interpolation?

Standard models for interpolation: deterministic and geostatistical prediction for continuous variables

Extensions to the standard model for non-standard data and non-planar locations

### Interpolation and geostatistics

Geostatistics is a bit like the alchemy of spatial statistics, focussed more on prediction than model fitting

Since the reason for modelling is chiefly prediction in pre-model-based geostatistics, and to a good extent in model-based geostatistics, we'll also keep to interpolation here

Interpolation is trying to make as good guesses as possible of the values of the variable of interest for places where there are no observations (can be in 1, 2, 3, $\ldots$ dimensions)

These are based on the relative positions of places with observations and places for which predictions are required, and the observed values at observations

Interpolation for point data involves estimates of a variable (or variables) from known observations at known positions to unknown positions

If the observation and prediction positions have point support, then we dealing with interpolation for point data

The underlying assumptions for all interpolation include distributional assumptions about the data, assumptions about the quality of the data and covariates, and assumptions about the quality of positional support and measurement

The standard model assumes planar geometry, error-free coordinates and covariates, and data that are observed as directly as possible from the same realization of the data generation process

## Modelling error processes

Since predictions are only of use if we know how far we can rely on them, all interpolation should try to accommodate uncertainty about measurements

If we are binning to try to obtain observations'', we are going much further than experimental scientists do in designing model matrices, we have much less control over the values of the predictors

Model-based geostatistics are among the techniques that can be used, but we can start from block kriging to get a feel for COSP

Very likely, Hierarchical or other Markov chain Monte Carlo (MCMC) models will be required to specify the errors to propagate

## Deterministic interpolation

We could say that we know very little about any spatial process in the DGP, and take the value at each prediction point as the value at the nearest observation, disregarding covariates

We could extend this by taking some measure of the values observed at nearby observations, for example a median or average

Inverse distance weighting with a power parameter interpolates by taking the distance-weighted mean of all, or a local region of, observations

Trend surfaces fit a surface through the observations using a polynomial in the point coordinates of the observations; splines also fit a surface based on local fits

### Statistical interpolation

While splines may have a statistical interpretation, they are often used deterministically, but as with IDW and trend surface, the fitted model may be chosen by cross-validation (eg. Geostatistical Analyst in ArcGIS)

It is also perfectly possible to fit an aspatial statistical model with covariates (linear, GLM, GAM, CART, etc.), and predict to locations for which observations on the covariates are available

Many of these can be extended to their mixed-model version, as LME, GLMM, GAMM, etc., using a spatial process model for random effects, or for example a spline surface in the observation coordinates (GAM)

The spatial process models are mostly geostatistical, so we'll focus on these

### Spatial processes

Assuming that we have a response variable and perhaps explanatory
variables observed on the same support and yielding a mean-stationary
error process, our interest is in finding out whether there is
still useful information in the error

The information may take
the form of spatial covariance, the error autocorrelation between
observation

This also involves the introduction of the concept of the random field, a
stochastic process in more than one dimension, as a representation of
space, where these can be continuous or discrete

The continuous form is:

\[
Z(\mathbf{s}) = \mu(\mathbf{s}) + W(\mathbf{s}) + \eta(\mathbf{s}) + \epsilon(\mathbf{s}),
\] 
where $Z(\mathbf{s})$ is a random field, $\mathbf{s} = [s_1, s_2, \ldots,
s_d]'$ are the coordinates of a spatial process indexed over $D \subset
\mathcal{R}^d$, the mean function $\mu(\mathbf{s})$ is the large-scale trend,
$W(\mathbf{s})$ is the smooth-scale variation and is a stationary
process with a covariance function, $\eta(\mathbf{s})$ is the often
unobservable micro-scale variation, and $\epsilon(\mathbf{s})$ is white
noise measurement error

### Fitting the covariance function

In geostatistics, two steps are involved in prediction from point data, first modelling the smooth-scale variation, then making the prediction from the mean function and this fitted model

The first step in practice involves fitting a variogram model to the observed differences in the residuals of the model after fitting the mean function between pairs of observation points

The fitting of a model to the empirical variogram may be done by hand and by a number of statistical techniques (which depend on assumptions)

Choosing a different variogram model may lead to differences in predictions; it may not be possible to choose a satisfactory model

### ESDA - geostatistics

It is probable that more exploratory spatial data analysis is
done in geostatistics than in the remaining domains of spatial data
analysis

It is easy to grasp why
interpolation is crucially dependent on identifying the right model,
in terms of the selection of observation locations, the fitting of models
of spatial autocorrelation, detecting useful covariates, and checking
the appropriateness of assumptions such as isotropy

Here we will use a data set of precipitation values for Switzerland,
discussed in Diggle and Ribeiro (2007),
and used in the Spatial Interpolation Comparison 97''
contest

The examples demonstrate that geostatistics software, here
\RR packages, provides much support for exploratory spatial
data analysis

## Swiss precipitation ESDA


Both **geoR** and **gstat** include data for preciptation for 467 met. stations in Switzerland, for 8 May 1986, measured in 0.1 mm. We'll fit with 100 training sites, and predict to the remaining 367 sites. **geoR** gives a the four-panel ESDA display that conveys a lot of information for the 100 training sites.


```{r , echo = TRUE}
library(geoR)
data(SIC)
```

```{r, echo = TRUE}
plot(sic.100, borders=sic.borders, lowess=TRUE)
```


### Variogram diagnostics


The first diagnostic plot provided in **gstat** is known as
an $h$-scatterplot, and conditions a scatterplot of the values at pairs
of locations on the binned distance $h_{ij}$ between them; the diagonal 
lines represent perfect correlation


```{r , echo = TRUE}
library(sf)
sic.100sf <- st_as_sf(cbind(as.data.frame(sic.100[[1]]), precip=sic.100[[2]], sic.100[[3]]), coords=1:2)
sic.allsf <- st_as_sf(cbind(as.data.frame(sic.all[[1]]), precip=sic.all[[2]], sic.all[[3]]), coords=1:2)
```



```{r , echo = TRUE}
library(gstat)
hscat(precip ~ altitude, data=sic.100sf, seq(0,120,20))
```


We now compute a variogram cloud plot and a plot of
empirical variogram values for 20 5km wide bins, for classical and robust
versions of the variogram. The bin borders are shown to highlight how the empirical variogram is constructed as a measure of
central tendency of squared differences in the variable of interest
between pairs of points whose inter-point distance falls into the bin


```{r , echo = TRUE}
g <- gstat(id="precip", formula=precip ~ altitude, data=sic.100sf)
evgm <- variogram(g, cutoff=100, width=5)
revgm <- variogram(g, cutoff=100, width=5, cressie=TRUE)
cevgm <- variogram(g, cutoff=100, width=5, cloud=TRUE)
```

```{r, echo = TRUE}
oopar <- par(mfrow=c(1,2))
plot(gamma ~ dist, cevgm, pch=".", cex=2, col="grey65", ylab="semivariance", xlab="distance")
lines(gamma ~ dist, evgm, lwd=2)
lines(gamma ~ dist, revgm, lwd=2, lty=2)
abline(v=seq(0,100,5), lty=2, col="grey50")
plot(gamma ~ dist, evgm, ylab="semivariance", xlab="distance", type="b", lwd=2)
points(gamma ~ dist, revgm, pch=3)
lines(gamma ~ dist, revgm, lty=2, lwd=2)
abline(v=seq(0,100,5), lty=2, col="grey50")
legend("topleft", legend=c("classic", "robust"), pch=c(1,3), lty=c(1,2), bty="n", lwd=2)
par(oopar)
```


We can close in on these within-bin distributions by using boxplots constructed from the **gstat** variogram cloud --- box widths proportional to pair counts in bins, classical empirical variogram shown as dashed line; the **fields** package
returns number summaries by bin in addition to the classical variogram
estimator in output from the `vgram` function


```{r, echo = TRUE}
dbin <- findInterval(cevgm$dist, seq(0, 100, 5), all.inside=TRUE)
wid <- tapply(cevgm$gamma, dbin, length)
boxplot(cevgm$gamma ~ dbin, width=wid, ylab="semivariance", xlab="distance", axes=FALSE)
axis(2)
axis(1, at=c(0.5, 5.5, 10.5, 15.5, 20.5), labels=c(0, 25, 50, 75, 100)) 
box()
lines(gamma ~ I(dist/5), evgm, lwd=2, lty=2)
```


Finally, we explore possible anisotropy in the data set. Using the same bins as earlier,
we add arguments to the `variogram` function to create objects
for plotting, a variogram map, and four empirical
variograms for four axes at $0\,^{\circ}$, $45\,^{\circ}$, $90\,^{\circ}$
and $135\,^{\circ}$; the variogram direction lines are coded in the
same way on both panels


```{r , echo = TRUE}
mevgm <- variogram(g, cutoff=100, width=5, map=TRUE)
aevgm <- variogram(g, cutoff=100, width=5, alpha=c(0, 45, 90, 135))
```

```{r, echo=TRUE}
library(RColorBrewer)
oopar <- par(mar=c(1,1,1,1))
image(mevgm$map, col=colorRampPalette(brewer.pal(7, "Blues")[-(6:7)])(20))
abline(v=0, lty=1)
abline(a=0, b=1, lty=2)
abline(h=0, lty=3)
abline(a=0, b=-1, lty=4)
par(oopar)
```

```{r, echo=TRUE}
library(lattice)
trellis.device(new=FALSE,color=FALSE)
plot(aevgm, multipanel=FALSE)
```

### Variogram fitting in geoR


First we will fit a Matern variogram model in **geoR** using weighted least squares and maximum likelihood:


```{r , echo = TRUE}
evg <- variog(sic.100, max.dist=200, trend=formula(~altitude), messages=FALSE)
fvg <- variofit(evg, messages=FALSE)
ml <- likfit(sic.100, ini.cov.pars=c(0.5, 0.5), trend=formula(~altitude), messages=FALSE)
```

```{r, echo=TRUE}
plot(evg)
lines(fvg)
lines(ml, lty=2)
legend("topleft", legend=c("WLS", "ML"), lty=1:2, bty="n")
```

### Variogram fitting in gstat


Next we will fit a Matern variogram model in **gstat**:


```{r , echo = TRUE}
evgm <- variogram(g, cutoff=200, width=5)
fevgm <- fit.variogram(evgm, vgm(psill=16000, model="Mat", range=30, nugget=1, kappa=0.5))
fevgm
```

```{r, echo=TRUE}
plot(evgm, model=fevgm)
```


## Kriging --- prediction from the variogram model

The geostatistical packages, like **gstat**, use formula objects in standard ways where possible, which allows for considerable flexibility:

```{r , echo = TRUE}
UK_fit <- gstat(g, id="precip", model=fevgm)
z <- predict(UK_fit, newdata=sic.allsf, debug.level=0)
sic.367sf <- sic.allsf[which(z$precip.var > 0.0001),]
z <- predict(UK_fit, newdata=sic.367sf, debug.level=0)
```


Using **geoR**, we get:

```{r , echo = TRUE, cache=TRUE}
kcwls <- krige.conv(sic.100, locations=st_coordinates(sic.367sf),
  krige=krige.control(obj.model=fvg, type.krige="OK",
  trend.d=formula(~altitude), trend.l=formula(~sic.367sf$altitude)))
kcml <- krige.conv(sic.100, locations=st_coordinates(sic.367sf),
 krige=krige.control(obj.model=ml, type.krige="OK",
 trend.d=formula(~altitude), trend.l=formula(~sic.367sf$altitude)))
kcB <- krige.bayes(sic.100, locations=st_coordinates(sic.367sf),
 model=model.control(trend.d=formula(~altitude),
 trend.l=formula(~sic.367sf$altitude)))
```

### MCMC draws for one prediction location


The point about the standard assumptions is that when they are met, the prediction standard errors are tractable --- we plot the MCMC prediction simulations for location 1:


```{r , echo = TRUE}
plot(density(kcB$predictive$simulations[1,]), ylim=c(0, 0.006))
abline(v=kcB$predictive$mean[1], col="red", lwd=2)
curve(dnorm(x, mean=kcB$predictive$mean[1],
 sd=sqrt(kcB$predictive$variance[1])), lty=2, lwd=2, from=-100, to=500, add=TRUE)
abline(v=sic.367sf$precip[1], col="blue", lwd=2)
```

### Kriging --- variogram automatic selection

The **automap** package builds on **gstat** to automate the choice of variogram model:

```{r , echo = TRUE}
library(automap)
aK <- autoKrige(formula=precip ~ altitude, input_data=as(sic.100sf, "Spatial"), new_data=as(sic.367sf, "Spatial"))
aK$var_model
```

```{r , echo=TRUE}
plot(aK)
```

## ML-based interpolation?

[@10.7287/peerj.preprints.26693v3] point to possible uses of ML technologies for interpolation, and give code examples on the https://envirometrix.github.io/PredictiveSoilMapping/ are provided in an ebook. First distance matrices are constructed and converted to data frames:

```{r, echo = TRUE}
#grid.dist0 <- GSIF::buffer.dist(sic.100SP["precip"], sic.367SP[1], as.factor(1:nrow(sic.100SP)))
dist0sf <- as.data.frame(st_distance(st_geometry(sic.100sf)))
names(dist0sf) <- paste("layer", names(dist0sf), sep=".")
dist1sf <- as.data.frame(st_distance(st_geometry(sic.367sf), st_geometry(sic.100sf)))
names(dist1sf) <- paste("layer", names(dist1sf), sep=".")
```

Then the observed responses and any covariates are added to the per-observation distances, and a formula constructed:

```{r, echo = TRUE}
rm.precip <- cbind(data.frame(precip=sic.100sf$precip, altitude=sic.100sf$altitude), dist0sf)
rm.precip1 <- cbind(data.frame(altitude=sic.367sf$altitude), dist1sf)
```

```{r, echo = TRUE}
dn0 <- paste(names(dist0sf), collapse="+")
fm0 <- as.formula(paste("precip ~ altitude +", dn0))
#fm0
```


The `ranger` function from the **ranger** package can be used for fast random forest fitting:

```{r, echo = TRUE}
library(ranger)
m.precip <- ranger(fm0, rm.precip, quantreg=TRUE, num.trees=150, seed=1)
m.precip
```

And make predictions from the fitted model for the 367 weather stations held back:

```{r, echo = TRUE}
quantiles <- c(pnorm(1, lower.tail=FALSE), 0.5, pnorm(1))
precip.rfd <- as.data.frame(predict(m.precip, rm.precip1, type="quantiles",
                                     quantiles=quantiles)$predictions)
```

```{r, echo = TRUE}
res <- cbind(sic.367sf[,"precip"], precip.rfd, as.data.frame(aK$krige_output)[,3:5])
res$rf_sd <- (res[[4]] - res[[2]])/2
names(res) <- make.names(names(res))
names(res)[c(2,4)] <- c("quantile= 0.159", "quantile= 0.841")
```



```{r, echo=TRUE}
library(tmap)
st_crs(res) <- 32662
tm_shape(res) + tm_symbols(col=c("precip", "var1.pred", "quantile..0.5"), pal="Blues", size=0.2) + tm_facets(free.scales=FALSE) + tm_layout(panel.labels=c("Preciptation", "Kriging predictons", "Random Forest predictions"))
```

```{r, echo=TRUE}
tm_shape(res) + tm_symbols(col=c("var1.stdev", "rf_sd"), pal="Reds", size=0.2) + tm_facets(free.scales=FALSE) + tm_layout(panel.labels=c("Kriging std. dev", "Random Forest 0.159-0.841 range"))
```

Then the observed responses and any covariates are added to the per-observation distances, and a formula constructed:

```{r, echo = TRUE}
xy100 <- st_coordinates(sic.100sf)
xy367 <- st_coordinates(sic.367sf)
rm.precipa <- cbind(rm.precip, x=xy100[,1], y=xy100[,2])
rm.precipa1 <- cbind(rm.precip1, x=xy367[,1], y=xy367[,2])
```

```{r, echo = TRUE}
fm1 <- update(fm0, . ~ . + x + y)
```

```{r, echo = TRUE}
m.precipa <- ranger(fm1, rm.precipa, quantreg=TRUE, num.trees=150, seed=1)
m.precipa
```

And make predictions from the fitted model for the 367 weather stations held back:

```{r, echo = TRUE}
quantiles <- c(pnorm(1, lower.tail=FALSE), 0.5, pnorm(1))
precipa.rfd <- as.data.frame(predict(m.precipa, rm.precipa1, type="quantiles",
                                     quantiles=quantiles)$predictions)
```


```{r, echo = TRUE}
resa <- cbind(sic.367sf[,"precip"], precipa.rfd, as.data.frame(aK$krige_output)[,3:5])
resa$rf_sda <- (resa[[4]] - resa[[2]])/2
names(resa) <- make.names(names(resa))
names(resa)[c(2,4)] <- c("quantile= 0.159", "quantile= 0.841")
```


```{r, echo=TRUE}
st_crs(resa) <- 32662
tm_shape(resa) + tm_symbols(col=c("precip", "var1.pred", "quantile..0.5"), pal="Blues", size=0.2) + tm_facets(free.scales=FALSE) + tm_layout(panel.labels=c("Preciptation", "Kriging predictons", "Random Forest predictions"))
```

```{r, echo=TRUE}
tm_shape(resa) + tm_symbols(col=c("var1.stdev", "rf_sda"), pal="Reds", size=0.2) + tm_facets(free.scales=FALSE) + tm_layout(panel.labels=c("Kriging std. dev", "Random Forest 0.159-0.841 range"))
```



# Point patterns


### Outline

What we see on a map is a pattern, or perhaps some patterns mixed
together.

It is not easy to work back from map pattern to the process or
processes that generated it/them.

Using a variety of approaches, we can explore and analyse point
patterns, also reviewing an important chapter in the development of
quantitative geography.

Practically, we will also see how we can try out different
approaches, and how their assumptions affect our conclusions.


### References

David O'Sullivan and David Unwin (2003) \emph{Geographical Information
Analysis}, Wiley, chapter 4, plus chapter 3 for the curious (or 2010, ch. 5 plus ch. 4);

Ian Smalley and David Unwin (1968) The formation and shape of
drumlins and their distribution and orientation in drumlin fields,
\emph{Journal of Glaciology}, 7, pp. 377--390; Alan R. Hill (1973) The distribution of drumlins in County Down, Ireland, \emph{Annals, AAG}, 63 (2). pp. 226--240.

Others may also like Trevor Bailey and Anthony Gatrell (1995) \emph{Interactive spatial data analysis}, Longman, chapter 3.



## Data, drumlins, County Down, Ireland

```{r, echo = TRUE}
library(sf)
drumlins <- st_geometry(st_read("drumlins.gpkg"))
```

A data set similar to the one refered to by O'Sullivan and Unwin on p. 100-101 is available in **spatial** in R (associated with Venables and Ripley (2002) Modern Applied Statistics with S) --- it is the one used by Upton and Fingleton, coded by Ripley. We have here copied the points to a shapefile.

![Hill, 1973](hill1a.png)
![Upton & Fingleton, 1985](hill2.png)


### Using **spatstat** with **sf**


```{r, echo = TRUE}
library(spatstat)
(drumlins_ppp <- as.ppp(drumlins))
```

Although **spatstat** and the **sp** classes have developed independently, they have a good deal in common, and point patterns, images and polygon windows can be exchanged


### Edges and plot


Point pattern objects need bounding windows to show where the population of data points were collected. The default window is the bounding box of the points, but others are available.

```{r, echo = TRUE}
bb <- boundingbox(drumlins_ppp)
ch <- convexhull.xy(drumlins_ppp)
rr <- ripras(drumlins_ppp)
drumlins_rr <- ppp(drumlins_ppp$x, drumlins_ppp$y, window=rr)
```


```{r, echo=TRUE}
plot(drumlins_ppp)
plot(bb, add=TRUE, border="darkgreen", lwd=2, lty=1)
plot(ch, add=TRUE, border="darkred", lwd=2, lty=3)
plot(rr, add=TRUE, border="orange", lwd=2, lty=2)
```



### Quadrat analysis


One legacy approach to point patterns, avoiding the drudge of measuring inter-point distances, has been to divide the study area into quadrats, and count the numbers of points falling into each quadrat. This can take the form of a 2D histogram, or be displayed as an image plot.

```{r, echo = TRUE}
qc <- quadratcount(drumlins_ppp)
```


```{r, echo=TRUE}
plot(drumlins, cex=0.8)
t3 <- cbind(expand.grid(x=attr(qc, "xbreaks")[1:5] + diff(attr(qc, "xbreaks"))[1]/2, y=rev(attr(qc, "ybreaks")[1:5] + diff(attr(qc, "ybreaks"))[1]/2)), qc=c(t(qc)))
text(t3[,1], t3[,2], t3[,3], cex=1.2, font=2, col="darkred")
abline(h=attr(qc, "ybreaks"))
abline(v=attr(qc, "xbreaks"))
```

 

### Quadrat tests

Chi-squared tests for Complete Spatial Randomness using quadrat counts may seem attractive, but suffer from the same problems as do histogram bins:

```{r, echo = TRUE}
quadrat.test(drumlins_ppp)
```


Just adding one more row and column of quadrats, or switching windows, changes our conclusion:

```{r, echo = TRUE}
quadrat.test(drumlins_ppp, nx=6)
quadrat.test(drumlins_rr)
```


### Density plots

Density plots use a 2D kernel, in **spatstat** a Gaussian kernel, to create smoothed histograms avoiding the problems of quadrat counts. The key argument to pass to the density method for point patterm objects is `sigma=`, which determines the bandwidth of the kernel. Since we can coerce the image objects output by the method to an **sp** class, we use this to cumulate density values for different values of sigma.

```{r, echo = TRUE}
crds <- crds <- st_coordinates(st_sample(st_as_sfc(rr), size=10000, type="regular"))
crds <- list(x=crds[,1], y=crds[,2])
library(raster)
k02 <- as(density(drumlins_rr, sigma=0.2, xy=crds), "RasterLayer")
k04 <- as(density(drumlins_rr, sigma=0.4, xy=crds), "RasterLayer")
k06 <- as(density(drumlins_rr, sigma=0.6, xy=crds), "RasterLayer")
k08 <- as(density(drumlins_rr, sigma=0.8, xy=crds), "RasterLayer")
rB <- brick(k02, k04, k06, k08)
library(stars)
rB_st <- st_as_stars(rB)
```


```{r, echo=TRUE}
library(tmap)
st_crs(rB_st) <- 32662
st_crs(drumlins) <- 32662
tm_shape(rB_st) + tm_raster(title="Density") + tm_layout(panel.labels=c("0.2", "0.4", "0.6", "0.8")) + tm_shape(drumlins) + tm_symbols(size=0.25, shape=4)
```


Narrower bandwidths yield more extreme values, broader bandwidths narrow the interquartile range. From this table, we can see how the change in the bandwidth is affecting the relative differences in our view of the local estimates of intensity.

```{r, echo = TRUE}
summary(rB)
```

```{r, echo = TRUE}
boxplot(rB)
```

### Nearest-neighbour distances


We can find and plot nearest neighbour distances, finding them with `nndist` --- plotting the empirical cumulative distribution function of the nearest neighbour distances is interesting:

```{r, echo = TRUE}
nns <- nndist(drumlins_rr)
summary(nns)
```


```{r, echo=TRUE}
plot(ecdf(nns))
```



### Using G-hat - empirical cumulative distribution function


The $\hat{G}$ measure turns out to be just the ECDF of the nearest neighbour distances, plotted by default with the expected CSR line; `Gest` returns binned values for a range of distance bins best chosen by the function:

```{r, echo = TRUE, eval=FALSE}
plot(ecdf(nns), xlim=c(0, 0.5))
plot(Gest(drumlins_ppp), add=TRUE, lwd=3)
```




If we generate many simulated CSR point patterns for the current window, we can use the `envelope` method to explore whether the observed $\hat{G}$ measures lie in relation to the simulated ones:

```{r, echo = TRUE}
n <- drumlins_rr$n
set.seed(121122)
ex <- expression(runifpoint(n, win=rr))
res <- envelope(drumlins_rr, Gest, nsim=99, simulate=ex, 
        verbose=FALSE, savefuns=TRUE)
```


```{r , echo=TRUE}
plot(res, xlim=c(0,0.7))
for(i in 2:100) lines(attr(res, "simfuns")[[1]], attr(res, "simfuns")[[i]], col="grey")
plot(res, add=TRUE, lwd=3, xlim=c(0,0.7))
```

 



### Clark/Evans R statistics

We can also compute the nearest neighbour based Clark/Evans R statistic :

```{r, echo = TRUE}
clarkevans(drumlins_ppp)
clarkevans(drumlins_rr, correction="none")
clarkevans(drumlins_rr, correction="guard", clipregion=erosion.owin(rr, r=1))
```


which seem to indicate that the observed and CSR expected distances are similar, but perhaps more evenly spaced than clustered.


### Was CSR a good idea?

From what we have seen, it appears the the drumlin summit points are more regularly than randomly distributed. If we think, however, the absence of short nearest neighbour distance may mean that they "push" each other apart (in fact this is about points not being a good way of representing ellipses) --- so we can try to simulate from a Simple Sequential Inhibition (SSI) process with a 180m inhibition radius instead of CSR:


```{r, echo = TRUE, cache=TRUE}
ex <- expression(rSSI(0.18, n, win=rr))
set.seed(121122)
res <- envelope(drumlins_rr, Gest, nsim=99, simulate=ex, 
                verbose=FALSE, savefuns=TRUE)
```


```{r, echo=TRUE}
null <- capture.output(plot(res, xlim=c(0,0.7)))
for(i in 2:100) lines(attr(res, "simfuns")[[1]], attr(res, "simfuns")[[i]], col="grey")
null <- capture.output(plot(res, add=TRUE, lwd=3, xlim=c(0,0.7)))
```



### K-hat with CSR simulation


As we know, G-hat uses nearest neighbour distances to express summary features of a point pattern. The K-hat function uses point intensities in rings spreading out from the points, and so uses more of the data to examine what is driving the process (reported here as L-hat):

```{r, echo = TRUE, cache=TRUE}
ex <- expression(runifpoint(n, win=rr))
set.seed(121122)
res <- envelope(drumlins_rr, Kest, nsim=99, simulate=ex, 
                verbose=FALSE, savefuns=TRUE)
```


```{r, echo=TRUE}
r <- res$r
Lhat <- function(k, r) { (sqrt(k/pi)) - r }
plot(r, Lhat(res$obs, r), type="n", ylab="L(r)", main="CSR simulation", ylim=c(-0.17, 0.1))
for(i in 2:100) lines(r, Lhat(attr(res, "simfuns")[[i]], r), col="grey")
lines(r, Lhat(res$obs, r), lwd=2, col="brown")
lines(r, Lhat(res$lo, r), lwd=2, col="black", lty=2)
lines(r, Lhat(res$hi, r), lwd=2, col="black", lty=2)
```

### K-hat with SSI simulation


From what we already know, drumlins represented as points appear to inhibit each other under a distance of about 200m, so running the $\hat{K}$ measure with an SSI process should show more of what is going on:

```{r, echo = TRUE, cache=TRUE}
ex <- expression(rSSI(0.18, n, win=rr))
set.seed(121122)
res <- envelope(drumlins_rr, Kest, nsim=99, simulate=ex, 
                verbose=FALSE, savefuns=TRUE)
```


```{r, echo=TRUE}
r <- res$r
Lhat <- function(k, r) { (sqrt(k/pi)) - r }
plot(r, Lhat(res$obs, r), type="n", ylab="L(r)", main="SSI simulation", ylim=c(-0.17, 0.1))
for(i in 2:100) lines(r, Lhat(attr(res, "simfuns")[[i]], r), col="grey")
lines(r, Lhat(res$obs, r), lwd=2, col="brown")
lines(r, Lhat(res$lo, r), lwd=2, col="black", lty=2)
lines(r, Lhat(res$hi, r), lwd=2, col="black", lty=2)
```


### Inhomogeneous K-hat with CSR simulation


Another possibility is that the CSR hypothesis is at error on assuming that the process is homogeneous --- we may also test against an inhomogeneous process using the `Kinhom` function. If its `lambda` argument is omitted, it does leave-one-out kernel smoothing to find $\lambda_i$ by omitting the $i$-th point:

```{r, echo = TRUE, cache=TRUE}
ex <- expression(runifpoint(n, win=rr))
set.seed(121122)
res <- envelope(drumlins_rr, Kinhom, nsim=99, simulate=ex, 
                verbose=FALSE, savefuns=TRUE)
```


```{r, echo=TRUE}
r <- res$r
Lhat <- function(k, r) { (sqrt(k/pi)) - r }
plot(r, Lhat(res$obs, r), type="n", ylab="L(r)", main="CSR simulation", ylim=c(-0.17, 0.1))
for(i in 2:100) lines(r, Lhat(attr(res, "simfuns")[[i]], r), col="grey")
lines(r, Lhat(res$obs, r), lwd=2, col="brown")
lines(r, Lhat(res$lo, r), lwd=2, col="black", lty=2)
lines(r, Lhat(res$hi, r), lwd=2, col="black", lty=2)
```

### Inhomogeneous $\hat{K}$ with SSI simulation


Finally, we round off with an inhomogeneous SSI process:

```{r, echo = TRUE, cache=TRUE}
ex <- expression(rSSI(0.18, n, win=rr))
set.seed(121122)
res <- envelope(drumlins_rr, Kinhom, nsim=99, simulate=ex, 
                verbose=FALSE, savefuns=TRUE)
```


```{r, echo=TRUE}
r <- res$r
Lhat <- function(k, r) { (sqrt(k/pi)) - r }
plot(r, Lhat(res$obs, r), type="n", ylab="L(r)", main="SSI simulation", ylim=c(-0.17, 0.1))
for(i in 2:100) lines(r, Lhat(attr(res, "simfuns")[[i]], r), col="grey")
lines(r, Lhat(res$obs, r), lwd=2, col="brown")
lines(r, Lhat(res$lo, r), lwd=2, col="black", lty=2)
lines(r, Lhat(res$hi, r), lwd=2, col="black", lty=2)
```


### Conclusions about drumlins (so far)

Comparing the SSI with the CSR results indicates that we can not only reject the CSR process as being that driving drumlin point locations, but we have good grounds to suppose that a spatial inhibition process is operating

It is also very possible that the process is inhomogeneous, that is that an omitted heterogeneity in the surface is influencing the point pattern

The minimum drumlin footprint is such that drumlins cannot be closer to each other than a certain minimum distance

At short range, the estimated L-hat values are lower than the lower envelope bounds, but only less than 0.4 distance units --- this corresponds to spatial inhibition

As the L-hat simulation values for the SSI process indicate, drumlins are not well represented by points, because they have area, even volume, and rarely overlap''

## Case/control point patterns

It is frequently the case that point patterns are not measured on homogeneous surfaces

One way to tackle this is, as in these examples from Zhang et al. (2009), to sample from the population at risk to form a control group

We are then interested in examining the spatial distribution of cases compared to the spatial distribution of controls

The cases are observations of schistosomiasis in Guichi, China, and the controls are taken from the polulation at risk

First we'll read in the points, enclosing polygon, and river banks:

```{r, echo = TRUE}
points <- st_read("cc.gpkg", layer="points")
rivers <- st_geometry(st_read("cc.gpkg", layer="rivers"))
poly <- st_geometry(st_read("cc.gpkg", layer="poly"))
```



```{r, echo=TRUE}
plot(poly)
plot(rivers, add=TRUE)
plot(st_geometry(points), pch=3:4, add=TRUE)
```

We coerce the **sp** objects to their **spatstat** representations, the points with marks:

```{r, echo = TRUE}
points$mark <- factor(points$mark)
points.ppp <- as.ppp(points)
points.ppp$window <- as.owin(poly)
summary(points.ppp)
```


```{r, echo=TRUE}
plot(split(points.ppp))
```


### Kernel density


We make a mask for the kernel density calculations, and show the overall density:

```{r, echo = TRUE}
XY <- st_coordinates(st_sample(poly, size=10000, type="regular"))
XY <- list(x=XY[,1], y=XY[,2])
Z <- density(points.ppp, xy=XY)
```


```{r, echo=TRUE}
plot(Z)
```


### Case/control kernels


The split density shows how the point patterns differ:

```{r, echo = TRUE}
Z <- density(split(points.ppp), xy=XY)
```


```{r, echo=TRUE}
plot(Z)
```

### Kernel ratio


We can also display the case density as a proportion of the overall density:

```{r, echo = TRUE}
pCases <- with(Z, eval.im(case/(case + control)))
```


```{r , echo=TRUE}
plot(pCases)
plot(points.ppp, add=TRUE)
```





### R's `sessionInfo()`

```{r sI, echo = TRUE}
sessionInfo()
```
